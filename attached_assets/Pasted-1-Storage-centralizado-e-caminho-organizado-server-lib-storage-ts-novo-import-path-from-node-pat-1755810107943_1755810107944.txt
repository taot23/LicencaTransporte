1) Storage centralizado e caminho organizado
server/lib/storage.ts (novo)
import path from "node:path";
import fs from "node:fs/promises";

const UPLOAD_BASE = process.env.UPLOAD_DIR || path.join(process.cwd(), "uploads");

function toSlug(raw: string): string {
  return (raw || "desconhecido")
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/(^-|-$)/g, "")
    .slice(0, 60);
}

async function exists(p: string) { try { await fs.stat(p); return true; } catch { return false; } }

export function buildLicenseDir(opts: { transporter: string; state: string; licenseNumber: string }) {
  const t = toSlug(opts.transporter);
  const uf = toSlug(opts.state).toUpperCase();
  const lic = toSlug(opts.licenseNumber);
  return {
    absDir: path.join(UPLOAD_BASE, "licenses", t, uf, lic),
    relUrlBase: `/uploads/licenses/${encodeURIComponent(t)}/${encodeURIComponent(uf)}/${encodeURIComponent(lic)}`
  };
}

export async function saveLicenseFile(params: {
  buffer: Buffer;
  originalName: string;    // ex.: "2025-08-07.pdf"
  transporter: string;     // ex.: "Transportadora X"
  state: string;           // ex.: "PR"
  licenseNumber: string;   // ex.: "AET-09466425"
}) {
  const { absDir, relUrlBase } = buildLicenseDir(params);
  await fs.mkdir(absDir, { recursive: true });

  const ext = (path.extname(params.originalName) || ".pdf").toLowerCase();
  const base = toSlug(path.basename(params.originalName, ext)) || "arquivo";
  let file = `${base}${ext}`;
  let outPath = path.join(absDir, file);
  let i = 1;
  while (await exists(outPath)) { file = `${base}-${i++}${ext}`; outPath = path.join(absDir, file); }

  await fs.writeFile(outPath, params.buffer);
  const publicUrl = `${relUrlBase}/${encodeURIComponent(file)}`;
  console.info("[UPLOAD] destino:", outPath, "url:", publicUrl);
  return { outPath, publicUrl };
}

Exemplo de uso (no endpoint que gera/salva PDF da licença)

Ajuste seu handler onde hoje o PDF é criado/salvo:

import { saveLicenseFile } from "./lib/storage";

// ...dentro do handler
// Busque meta no DB (ajuste nomes de campos/tabelas):
const meta = await db.one<{ transporter:string; state:string; license_number:string; }>(`
  SELECT t.name AS transporter,
         COALESCE(l.state, t.state) AS state,
         l.number AS license_number
  FROM licenses l
  JOIN transporters t ON t.id = l.transporter_id
  WHERE l.id = $1
`, [licenseId]);

// Gere o PDF -> buffer + nome sugerido
const { buffer, suggestedName } = await generateLicensePdf(licenseId);

const { publicUrl } = await saveLicenseFile({
  buffer,
  originalName: suggestedName ?? `${meta.license_number}.pdf`,
  transporter: meta.transporter,
  state: meta.state,
  licenseNumber: meta.license_number
});

// (Opcional) persistir no banco:
await db.none(`UPDATE licenses SET file_url = $1 WHERE id = $2`, [publicUrl, licenseId]);

res.json({ ok: true, url: publicUrl });


Para uploads manuais (multipart/form-data), passe req.file.buffer no saveLicenseFile(...) com os mesmos metadados.

2) Boot estável, envs e healthcheck
ecosystem.config.cjs

Se preferir ficar em TS direto, troque script para server/index.ts + interpreter: npx, interpreter_args: tsx. Recomendo rodar build JS em produção.

module.exports = {
  apps: [
    {
      name: "aet-license-system",
      cwd: "/var/www/aetlicensesystem/LicencaTransporte",
      script: "server/dist/index.js",   // gere com tsc/tsup
      instances: 1,                     // "max" depois
      exec_mode: "cluster",
      watch: false,
      env: {
        NODE_ENV: "production",
        PORT: 5050,
        UPLOAD_DIR: "/var/uploads",
        DATABASE_URL: "postgresql://aetuser:*****@localhost:5432/aetlicensesystem",
        SESSION_SECRET: "troque_por_uma_chave_unica_longa"
      }
    }
  ]
}

server/index.ts (trecho: dotenv opcional + health + estático)
if (process.env.NODE_ENV !== "production") { require("dotenv").config(); }

import path from "node:path";
import express from "express";
const app = express();

const UPLOAD_DIR = process.env.UPLOAD_DIR || path.join(process.cwd(), "uploads");
app.use("/uploads", express.static(UPLOAD_DIR, {
  fallthrough: false, etag: true, maxAge: "30d", immutable: true
}));

app.get("/healthz", (_req, res) => res.send("ok"));

// ...restante do bootstrap/rotas

3) Trigger de updated_at e colunas padrão
migrations/2025-08-21-updated-at.sql
-- função padrão
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN NEW.updated_at := now(); RETURN NEW; END $$;

-- utilitário: adiciona created_at/updated_at se faltar e cria trigger
DO $$
DECLARE r record;
BEGIN
  FOR r IN
    SELECT table_schema, table_name
    FROM information_schema.tables
    WHERE table_schema = 'public' AND table_type='BASE TABLE'
      AND table_name IN ('vehicles','license_vehicles','licenses','transporters','vehicle_set_types')
  LOOP
    EXECUTE format('ALTER TABLE %I.%I ADD COLUMN IF NOT EXISTS created_at timestamptz NOT NULL DEFAULT now();', r.table_schema, r.table_name);
    EXECUTE format('ALTER TABLE %I.%I ADD COLUMN IF NOT EXISTS updated_at timestamptz NOT NULL DEFAULT now();', r.table_schema, r.table_name);
    EXECUTE format('DROP TRIGGER IF EXISTS trg_%I_updated_at ON %I.%I;', r.table_name, r.table_schema, r.table_name);
    EXECUTE format('CREATE TRIGGER trg_%I_updated_at BEFORE UPDATE ON %I.%I
                    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();',
                    r.table_name, r.table_schema, r.table_name);
  END LOOP;
END $$;


Se usa Drizzle/Prisma, converta para migração da sua tool. O importante é não ter trigger apontando para coluna inexistente.

4) Script para reorganizar arquivos antigos (migrar para a nova árvore)
scripts/reorganizar-licencas.ts
import path from "node:path";
import fs from "node:fs/promises";
import { Client } from "pg";
import { saveLicenseFile } from "../server/lib/storage";

const UPLOAD_BASE = process.env.UPLOAD_DIR || "/var/uploads";

async function main() {
  const db = new Client({ connectionString: process.env.DATABASE_URL });
  await db.connect();

  const { rows } = await db.query(`
    SELECT l.id, l.number AS license_number,
           COALESCE(l.state, t.state) AS state,
           t.name AS transporter,
           l.file_url
    FROM licenses l
    JOIN transporters t ON t.id = l.transporter_id
    WHERE l.file_url IS NOT NULL
  `);

  for (const r of rows) {
    const rel = r.file_url.replace(/^\/uploads\//, "");
    const oldAbs = path.join(UPLOAD_BASE, rel);
    try {
      const buf = await fs.readFile(oldAbs);
      const { publicUrl } = await saveLicenseFile({
        buffer: buf,
        originalName: path.basename(oldAbs),
        transporter: r.transporter,
        state: r.state,
        licenseNumber: r.license_number
      });
      if (publicUrl !== r.file_url) {
        await db.query(`UPDATE licenses SET file_url = $1 WHERE id = $2`, [publicUrl, r.id]);
        await fs.rm(oldAbs).catch(() => {});
        console.log(`✔ ${r.file_url} -> ${publicUrl}`);
      }
    } catch (e:any) {
      console.error(`✖ falha em ${oldAbs}: ${e.message}`);
    }
  }

  await db.end();
}

main().catch(e => { console.error(e); process.exit(1); });


Rodar no servidor:

export NODE_ENV=production
export UPLOAD_DIR=/var/uploads
export DATABASE_URL="postgresql://aetuser:***@localhost:5432/aetlicensesystem"
node --loader tsx scripts/reorganizar-licencas.ts  # ou compile para JS e rode com node